#!/usr/bin/env python3
"""
Fetch NIST XCOM data and regenerate xrl/data/nist_xcom.py
==========================================================

Fetches tabulated μ/ρ data for each element from the NIST Physical
Reference Data server, computes compound tables via the mixture rule,
and writes a fresh ``xrl/data/nist_xcom.py`` with updated timestamps.

Usage::

    pip install requests beautifulsoup4
    python scripts/fetch_nist_xcom.py

Requirements:
    requests >= 2.28
    beautifulsoup4 >= 4.11

Author: Abhineet Agarwal
"""

import sys
import re
import textwrap
from datetime import date
from pathlib import Path

try:
    import requests
    from bs4 import BeautifulSoup
except ImportError:
    sys.exit(
        "Missing dependencies. Install with:\n"
        "    pip install requests beautifulsoup4"
    )

import numpy as np

# ---------------------------------------------------------------------------
# NIST XCOM element table URLs
# Z -> URL pattern: https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/zXX.html
# ---------------------------------------------------------------------------

ELEMENTS = {
    'H':  1,
    'C':  6,
    'N':  7,
    'O':  8,
    'Si': 14,
    'Ta': 73,
    'W':  74,
    'Au': 79,
}

BASE_URL = "https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/z{:02d}.html"


def fetch_element(symbol: str, z: int) -> tuple[list[float], list[float]]:
    """Fetch and parse NIST XCOM table for element Z.

    Returns:
        (energy_MeV_list, mu_rho_list) — total with coherent.
    """
    url = BASE_URL.format(z)
    print(f"  Fetching {symbol} (Z={z}) from {url}")
    resp = requests.get(url, timeout=30)
    resp.raise_for_status()

    soup = BeautifulSoup(resp.text, 'html.parser')
    # NIST tables use <pre> blocks or plain <table>; try both
    pre = soup.find('pre')
    if pre:
        text = pre.get_text()
    else:
        text = soup.get_text()

    energies, mu_rhos = [], []
    # Match lines: energy  mu/rho_coherent  mu/rho_incoherent  mu/rho_total  ...
    # The 4th column is total with coherent
    pattern = re.compile(
        r'^\s*(\d+\.\d+[Ee][+-]?\d+)'   # energy
        r'\s+(\d+\.\d+[Ee][+-]?\d+)'    # mu/rho coherent
        r'\s+(\d+\.\d+[Ee][+-]?\d+)'    # mu/rho incoherent
        r'\s+(\d+\.\d+[Ee][+-]?\d+)',   # mu/rho total (col 4)
        re.MULTILINE
    )
    for m in pattern.finditer(text):
        energies.append(float(m.group(1)))
        mu_rhos.append(float(m.group(4)))

    if not energies:
        raise ValueError(f"Could not parse data for {symbol} from {url}")

    return energies, mu_rhos


def mixture_rule(
    constituents: list[tuple[float, list[float], list[float]]]
) -> tuple[list[float], list[float]]:
    """Compute compound μ/ρ via mixture rule on a union energy grid.

    constituents: [(weight_fraction, energy_MeV, mu_rho), ...]
    """
    all_e = sorted(set(
        e for _, energies, _ in constituents for e in energies
    ))
    all_e_arr = np.array(all_e)
    mu_compound = np.zeros(len(all_e))

    for w_i, e_i, mu_i in constituents:
        e_arr = np.array(e_i, dtype=float)
        mu_arr = np.array(mu_i, dtype=float)
        # Handle edge pairs
        for idx in range(1, len(e_arr)):
            if e_arr[idx] <= e_arr[idx - 1]:
                e_arr[idx] = e_arr[idx - 1] + 1e-12
        log_e = np.log10(e_arr)
        log_mu = np.log10(mu_arr)
        interp_log_mu = np.interp(np.log10(all_e_arr), log_e, log_mu,
                                  left=log_mu[0], right=log_mu[-1])
        mu_compound += w_i * 10.0 ** interp_log_mu

    return all_e, mu_compound.tolist()


def format_array(values: list[float], indent: int = 8) -> str:
    """Format a float list as a multi-line numpy array literal."""
    lines = []
    row = []
    for v in values:
        row.append(f"{v:.6e}")
        if len(row) == 6:
            lines.append(" " * indent + ", ".join(row) + ",")
            row = []
    if row:
        lines.append(" " * indent + ", ".join(row) + ",")
    return "\n".join(lines)


def generate_module(element_data: dict[str, tuple]) -> str:
    """Generate the Python source for xrl/data/nist_xcom.py."""
    today = date.today().isoformat()

    lines = [
        '"""',
        "NIST XCOM Tabulated Mass Attenuation Coefficients",
        "==================================================",
        "",
        "Auto-generated by scripts/fetch_nist_xcom.py",
        f"Data retrieved: {today}",
        "",
        "Source: NIST Physical Reference Data",
        "  https://physics.nist.gov/PhysRefData/XrayMassCoef/",
        '"""',
        "",
        "import numpy as np",
        "from scipy.interpolate import interp1d",
        "",
        "# ---------------------------------------------------------------------------",
        "# Elemental tables",
        "# ---------------------------------------------------------------------------",
    ]

    for sym, (energies, mu_rhos) in element_data.items():
        lines += [
            "",
            f"_{sym.upper()} = {{",
            "    'energy_MeV': np.array([",
            format_array(energies),
            "    ]),",
            "    'mu_rho': np.array([",
            format_array(mu_rhos),
            "    ]),",
            "}",
        ]

    # Compound definitions (hardcoded formulas, data computed above)
    lines += textwrap.dedent("""
    # ---------------------------------------------------------------------------
    # Helpers and compound tables
    # ---------------------------------------------------------------------------

    def _log_interp(e_grid, mu_grid):
        e = np.array(e_grid, dtype=float)
        mu = np.array(mu_grid, dtype=float)
        eps = 1e-9
        for i in range(1, len(e)):
            if e[i] <= e[i - 1]:
                e[i] = e[i - 1] + eps
        return interp1d(np.log10(e), np.log10(mu), kind='linear',
                        bounds_error=False, fill_value='extrapolate')


    def _eval_interp(fn, energy_MeV):
        return 10.0 ** fn(np.log10(energy_MeV))


    def _make_compound(constituents):
        all_e = np.unique(np.concatenate([c['energy_MeV'] for _, c in constituents]))
        mu_c = np.zeros_like(all_e)
        for w_i, elem in constituents:
            f = _log_interp(elem['energy_MeV'], elem['mu_rho'])
            mu_c += w_i * np.array([_eval_interp(f, e) for e in all_e])
        return {'energy_MeV': all_e, 'mu_rho': mu_c}


    _SI3N4 = _make_compound([(0.6007, _SI), (0.3993, _N)])
    _SIC   = _make_compound([(0.7005, _SI), (0.2995, _C)])
    _PMMA_COMPOUND = _make_compound([(0.5998, _C), (0.0806, _H), (0.3196, _O)])

    _TABLES = {
        'Tantalum':        _TA,   'Ta':    _TA,
        'Tungsten':        _W,    'W':     _W,
        'Gold':            _AU,   'Au':    _AU,
        'Silicon':         _SI,   'Si':    _SI,
        'Nitrogen':        _N,    'N':     _N,
        'Carbon':          _C,    'C':     _C,
        'Oxygen':          _O,    'O':     _O,
        'Hydrogen':        _H,    'H':     _H,
        'Silicon Nitride': _SI3N4,'Si3N4': _SI3N4,
        'Silicon Carbide': _SIC,  'SiC':   _SIC,
        'PMMA':            _PMMA_COMPOUND,
    }

    _INTERPOLATORS = {}


    def _get_interpolator(key):
        if key not in _INTERPOLATORS:
            tbl = _TABLES[key]
            _INTERPOLATORS[key] = _log_interp(tbl['energy_MeV'], tbl['mu_rho'])
        return _INTERPOLATORS[key]


    def get_mu_rho(material_key: str, energy_kev: float) -> float:
        \"\"\"Return mu/rho (cm²/g) at energy_kev via NIST XCOM log-log interpolation.\"\"\"
        if material_key not in _TABLES:
            raise KeyError(f"No NIST XCOM data for '{material_key}'.")
        return float(_eval_interp(_get_interpolator(material_key), energy_kev * 1e-3))
    """).splitlines()

    return "\n".join(lines) + "\n"


def main():
    print("Fetching NIST XCOM data...")
    element_data: dict[str, tuple] = {}
    for sym, z in ELEMENTS.items():
        try:
            e, mu = fetch_element(sym, z)
            element_data[sym] = (e, mu)
            print(f"    {sym}: {len(e)} data points")
        except Exception as exc:
            print(f"    ERROR for {sym}: {exc}")
            sys.exit(1)

    out_path = Path(__file__).parent.parent / "xrl" / "data" / "nist_xcom.py"
    print(f"\nWriting {out_path} ...")
    source = generate_module(element_data)
    out_path.write_text(source, encoding="utf-8")
    print("Done.")


if __name__ == "__main__":
    main()
